{"version":3,"file":"index.umd.js","sources":["../src/utils/directive-helpers.ts","../src/directives/currency.ts","../src/directives/number.ts","../src/directives/datetime.ts","../src/utils/auto-detect.ts","../src/index.ts"],"sourcesContent":["/***\n * SER:\n *\n * Helper functions and types for Vue.js formatting directives\n * This will do a DRY implementation of common logic used across\n * different formatting directives like number, currency, and datetime.\n */\n\nimport type { DirectiveBinding } from \"vue\";\nimport { getGlobalOptions } from \"../index\";\n\n/**\n * Common directive binding modes\n */\nexport type DirectiveMode = \"implicit\" | \"options\" | \"explicit\";\n\n/**\n * Base options that all formatting directives share\n */\nexport interface BaseFormatOptions {\n  locale?: string;\n  accessibility?: boolean;\n  class?: string;\n}\n\n/**\n * Result of parsing directive binding\n */\nexport interface DirectiveParseResult<T extends BaseFormatOptions> {\n  mode: DirectiveMode;\n  value: unknown;\n  options: T;\n}\n\n// Store for captured textContent (used for implicit mode reactivity)\nconst capturedTextContent = new WeakMap<HTMLElement, string>();\nconst mutationObservers = new WeakMap<HTMLElement, MutationObserver>();\n\n/**\n * Common directive lifecycle handlers\n */\nexport function createDirective(\n  formatter: (el: HTMLElement, binding: DirectiveBinding) => void,\n) {\n  const pendingTasks = new WeakMap<HTMLElement, boolean>();\n  const latestBindings = new WeakMap<HTMLElement, DirectiveBinding>();\n\n  const scheduleFormat = (el: HTMLElement, binding: DirectiveBinding) => {\n    // Capture the current textContent synchronously before any async operations\n    // This is crucial for implicit mode where Vue updates the textContent\n    const currentText = el.textContent || \"\";\n    capturedTextContent.set(el, currentText);\n\n    latestBindings.set(el, binding);\n\n    if (pendingTasks.get(el)) {\n      return;\n    }\n\n    pendingTasks.set(el, true);\n    queueMicrotask(() => {\n      pendingTasks.delete(el);\n      const currentBinding = latestBindings.get(el) || binding;\n      formatter(el, currentBinding);\n    });\n  };\n\n  const mountDirective = (el: HTMLElement, binding: DirectiveBinding) => {\n    // Warn about implicit mode with reactive data\n    if (binding.value === undefined || binding.value === null) {\n      const globalOpts = getGlobalOptions();\n      if (globalOpts.debug) {\n        console.warn(\n          \"[VueTextUtils] Implicit mode detected. Note: Implicit mode with {{ }} interpolation does NOT support reactivity. \" +\n            'For reactive data, use explicit mode instead: v-currency=\"yourValue\" instead of v-currency>{{ yourValue }}',\n        );\n      }\n    }\n    scheduleFormat(el, binding);\n  };\n\n  const unmountDirective = (el: HTMLElement) => {\n    // Clean up the observer when the directive is unmounted\n    const observer = mutationObservers.get(el);\n    if (observer) {\n      observer.disconnect();\n      mutationObservers.delete(el);\n    }\n  };\n\n  return {\n    mounted: mountDirective,\n    updated: scheduleFormat,\n    unmounted: unmountDirective,\n  };\n}\n\n/**\n * Get the default locale with proper priority\n */\nexport function getDefaultLocale(binding: DirectiveBinding): string {\n  const globalOpts = getGlobalOptions();\n  const instance = binding.instance as { $i18n?: { locale?: string } } | null;\n  return instance?.$i18n?.locale || globalOpts.locale || \"en-US\";\n}\n\n/**\n * Determine directive mode and extract value/options\n */\nexport function parseDirectiveBinding<T extends BaseFormatOptions>(\n  binding: DirectiveBinding,\n  defaultOptions: T,\n): DirectiveParseResult<T> {\n  const { value } = binding;\n\n  if (value === undefined || value === null) {\n    return {\n      mode: \"implicit\",\n      value: undefined,\n      options: { ...defaultOptions },\n    };\n  }\n\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    !(value instanceof Date)\n  ) {\n    // Check if the object has a 'value' property for explicit mode with options\n    const hasValueProp = \"value\" in value && value.value !== undefined;\n\n    if (hasValueProp) {\n      // Explicit mode with options: { value: 123, currency: 'EUR' }\n      // This supports reactivity because the value is passed as binding.value.value\n      const { value: extractedValue, ...restOptions } = value;\n      return {\n        mode: \"explicit\",\n        value: extractedValue,\n        options: { ...defaultOptions, ...restOptions },\n      };\n    } else {\n      // Implicit mode with options: v-currency=\"{ currency: 'EUR' }\">{{ value }}\n      // Note: This does NOT support reactivity with {{ }} interpolation\n      return {\n        mode: \"options\",\n        value: undefined,\n        options: { ...defaultOptions, ...value },\n      };\n    }\n  }\n\n  return {\n    mode: \"explicit\",\n    value: value,\n    options: { ...defaultOptions },\n  };\n}\n\n/**\n * Extract value from element or data attribute\n */\nexport function extractElementValue(\n  el: HTMLElement,\n  fallback: string = \"\",\n): string {\n  // Try to get the captured textContent from Vue's render (before any async operations)\n  const captured = capturedTextContent.get(el);\n  const textContent = captured !== undefined ? captured : el.textContent || \"\";\n  const storedRawValue = el.getAttribute(\"data-raw-value\");\n\n  // Check if we have a stored raw value from previous formatting\n  if (storedRawValue !== null) {\n    // If the text content is the same as the stored raw value, return it\n    if (textContent.trim() === storedRawValue.trim()) {\n      return storedRawValue;\n    }\n\n    // Text content has changed - determine if it's a Vue update or our own formatting\n    // Check if the text content appears to be a plain number (potential raw value from Vue)\n    const textAsNumber = textContent.replace(/^\\s+|\\s+$/g, \"\");\n    const isLikelyRawNumber = /^-?\\d+(\\.\\d+)?$/.test(textAsNumber);\n\n    // Check if the stored raw value is a plain number\n    const storedAsNumber = storedRawValue.replace(/^\\s+|\\s+$/g, \"\");\n    const storedIsRawNumber = /^-?\\d+(\\.\\d+)?$/.test(storedAsNumber);\n\n    // If both look like raw numbers and they're different, Vue has updated the value\n    if (\n      isLikelyRawNumber &&\n      storedIsRawNumber &&\n      textAsNumber !== storedAsNumber\n    ) {\n      el.setAttribute(\"data-raw-value\", textContent.trim());\n      return textContent.trim();\n    }\n\n    // If the current text looks like a raw number but stored value doesn't,\n    // Vue has updated with a new raw value\n    if (isLikelyRawNumber && !storedIsRawNumber) {\n      el.setAttribute(\"data-raw-value\", textContent.trim());\n      return textContent.trim();\n    }\n\n    // Default case: assume the directive hasn't run yet and use stored raw value\n    return storedRawValue;\n  }\n\n  // If no stored value, use text content and store it for future updates\n  const trimmedContent = textContent.trim();\n  if (trimmedContent) {\n    el.setAttribute(\"data-raw-value\", trimmedContent);\n  }\n\n  // Fall back to data-value attribute or the provided fallback\n  return trimmedContent || el.getAttribute(\"data-value\") || fallback;\n}\n\n/**\n * Apply common accessibility attributes and classes\n */\nexport function applyCommonAttributes(\n  el: HTMLElement,\n  options: BaseFormatOptions,\n  formatted: string,\n  ariaPrefix: string,\n  additionalAttrs: Record<string, string> = {},\n  rawValue?: string | number,\n): void {\n  // Update element content\n  el.textContent = formatted;\n\n  // Store the original raw value for future updates\n  if (rawValue !== undefined) {\n    el.setAttribute(\"data-raw-value\", String(rawValue));\n  }\n\n  // Add accessibility attributes if enabled\n  if (options.accessibility) {\n    el.setAttribute(\"aria-label\", `${ariaPrefix}: ${formatted}`);\n\n    // Apply additional attributes\n    Object.entries(additionalAttrs).forEach(([key, value]) => {\n      el.setAttribute(key, value);\n    });\n  }\n\n  // Add custom class if provided\n  if (options.class) {\n    el.classList.add(options.class);\n  }\n}\n\n/**\n * Handle directive errors consistently\n */\nexport function handleDirectiveError(\n  directiveName: string,\n  error: unknown,\n  value?: unknown,\n): void {\n  if (error instanceof Error) {\n    console.error(`${directiveName} directive formatting error:`, error);\n  } else {\n    console.warn(`${directiveName} directive: Invalid value:`, value);\n  }\n}\n\n/**\n * Validate numeric input\n */\nexport function validateNumericValue(\n  value: unknown,\n  directiveName: string,\n): number | null {\n  const numericValue = parseFloat(String(value));\n  if (isNaN(numericValue)) {\n    console.warn(`${directiveName} directive: Invalid numeric value:`, value);\n    return null;\n  }\n  return numericValue;\n}\n\n/**\n * Validate date input\n */\nexport function validateDateValue(\n  value: unknown,\n  directiveName: string,\n): Date | null {\n  if (value instanceof Date) {\n    return value;\n  }\n\n  if (typeof value === \"string\" || typeof value === \"number\") {\n    const parsed = new Date(value);\n    if (isNaN(parsed.getTime())) {\n      console.warn(`${directiveName} directive: Invalid date value:`, value);\n      return null;\n    }\n    return parsed;\n  }\n\n  console.warn(`${directiveName} directive: Invalid date value:`, value);\n  return null;\n}\n","import type { Directive, DirectiveBinding } from \"vue\";\nimport { getGlobalOptions } from \"../index\";\nimport {\n  createDirective,\n  parseDirectiveBinding,\n  extractElementValue,\n  applyCommonAttributes,\n  handleDirectiveError,\n  validateNumericValue,\n  getDefaultLocale,\n  type BaseFormatOptions,\n} from \"../utils/directive-helpers\";\n\n// Extend base options with currency-specific options\ninterface CurrencyOptions extends BaseFormatOptions {\n  currency?: string;\n  currencyDisplay?: \"symbol\" | \"code\" | \"name\";\n  minimumFractionDigits?: number;\n  maximumFractionDigits?: number;\n}\n\n// Currency formatting directive\nconst CurrencyDirective: Directive = createDirective(formatCurrency);\n\nfunction formatCurrency(el: HTMLElement, binding: DirectiveBinding) {\n  const { arg } = binding;\n  const globalOpts = getGlobalOptions();\n\n  // Get default options\n  const defaultLocale = getDefaultLocale(binding);\n  const defaultCurrency = arg || globalOpts.defaultCurrency || \"USD\";\n\n  const defaultOptions: CurrencyOptions = {\n    currency: defaultCurrency,\n    currencyDisplay: \"symbol\",\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n    accessibility: true,\n    locale: defaultLocale,\n  };\n\n  // Parse the directive binding\n  const { mode, value, options } = parseDirectiveBinding(\n    binding,\n    defaultOptions,\n  );\n\n  // Override currency if arg is provided (for options mode)\n  if (mode === \"options\" && arg) {\n    options.currency = arg;\n  }\n\n  // Get the numeric value based on mode\n  let numericValue: number | null;\n  let rawValue: string | number;\n\n  if (mode === \"implicit\" || mode === \"options\") {\n    rawValue = extractElementValue(el, \"0\");\n    numericValue = validateNumericValue(rawValue, \"Currency\");\n  } else {\n    rawValue = value as string | number;\n    numericValue = validateNumericValue(rawValue, \"Currency\");\n  }\n\n  if (numericValue === null) {\n    return;\n  }\n\n  try {\n    // Use Intl.NumberFormat for currency formatting\n    const formatter = new Intl.NumberFormat(options.locale, {\n      style: \"currency\",\n      currency: options.currency,\n      currencyDisplay: options.currencyDisplay,\n      minimumFractionDigits: options.minimumFractionDigits,\n      maximumFractionDigits: options.maximumFractionDigits,\n    });\n\n    const formatted = formatter.format(numericValue);\n\n    // Apply common attributes and additional currency-specific attributes\n    applyCommonAttributes(\n      el,\n      options,\n      formatted,\n      \"Currency\",\n      {\n        \"data-currency-value\": numericValue.toString(),\n        \"data-currency-code\": options.currency || \"USD\",\n      },\n      rawValue,\n    );\n  } catch (error) {\n    handleDirectiveError(\"Currency\", error, value);\n  }\n}\n\nexport default CurrencyDirective;\n","import type { Directive, DirectiveBinding } from \"vue\";\nimport {\n  createDirective,\n  parseDirectiveBinding,\n  extractElementValue,\n  applyCommonAttributes,\n  handleDirectiveError,\n  validateNumericValue,\n  getDefaultLocale,\n  type BaseFormatOptions,\n} from \"../utils/directive-helpers\";\n\n// Extend base options with number-specific options\ninterface NumberOptions extends BaseFormatOptions {\n  minimumFractionDigits?: number;\n  maximumFractionDigits?: number;\n  useGrouping?: boolean;\n  percentage?: boolean;\n}\n\n/**\n * Number formatting directive\n */\nconst NumberDirective: Directive = createDirective(formatNumber);\n\nfunction formatNumber(el: HTMLElement, binding: DirectiveBinding) {\n  // Get default options\n  const defaultLocale = getDefaultLocale(binding);\n\n  const defaultOptions: NumberOptions = {\n    minimumFractionDigits: undefined,\n    maximumFractionDigits: undefined,\n    useGrouping: true,\n    percentage: false,\n    accessibility: true,\n    locale: defaultLocale,\n  };\n\n  // Parse the directive binding\n  const { mode, value, options } = parseDirectiveBinding(\n    binding,\n    defaultOptions,\n  );\n\n  // Get the numeric value based on mode\n  let numericValue: number | null;\n  let rawValue: string | number;\n\n  if (mode === \"implicit\" || mode === \"options\") {\n    rawValue = extractElementValue(el, \"0\");\n    numericValue = validateNumericValue(rawValue, \"Number\");\n  } else {\n    rawValue = value as string | number;\n    numericValue = validateNumericValue(rawValue, \"Number\");\n  }\n\n  if (numericValue === null) {\n    return;\n  }\n\n  try {\n    // Use Intl.NumberFormat for number formatting\n    const formatterOptions: Intl.NumberFormatOptions = {\n      useGrouping: options.useGrouping,\n      minimumFractionDigits: options.minimumFractionDigits,\n      maximumFractionDigits: options.maximumFractionDigits,\n    };\n\n    const formatter = new Intl.NumberFormat(options.locale, formatterOptions);\n\n    let formatted: string;\n    if (options.percentage) {\n      // For percentage, multiply by 100 and add % symbol\n      formatted = formatter.format(numericValue * 100) + \"%\";\n    } else {\n      formatted = formatter.format(numericValue);\n    }\n\n    // Apply common attributes and additional number-specific attributes\n    applyCommonAttributes(\n      el,\n      options,\n      formatted,\n      \"Number\",\n      {\n        \"data-number-value\": numericValue.toString(),\n      },\n      rawValue,\n    );\n  } catch (error) {\n    handleDirectiveError(\"Number\", error, value);\n  }\n}\n\nexport default NumberDirective;\n","import type { Directive, DirectiveBinding } from \"vue\";\nimport { getGlobalOptions } from \"../index\";\nimport {\n  createDirective,\n  parseDirectiveBinding,\n  extractElementValue,\n  applyCommonAttributes,\n  handleDirectiveError,\n  validateDateValue,\n  getDefaultLocale,\n  type BaseFormatOptions,\n} from \"../utils/directive-helpers\";\n\n// Extend base options with datetime-specific options\ninterface DateTimeOptions extends BaseFormatOptions {\n  dateStyle?: \"full\" | \"long\" | \"medium\" | \"short\" | \"none\";\n  timeStyle?: \"full\" | \"long\" | \"medium\" | \"short\" | \"none\";\n  timeZone?: string;\n  inputFormat?: \"auto\";\n}\n\n/**\n * DateTime formatting directive\n */\nconst DateTimeDirective: Directive = createDirective(formatDateTime);\n\nfunction formatDateTime(el: HTMLElement, binding: DirectiveBinding) {\n  const globalOpts = getGlobalOptions();\n\n  // Get default options\n  const defaultLocale = getDefaultLocale(binding);\n  const defaultTimezone = globalOpts.defaultTimezone || \"UTC\";\n\n  const defaultOptions: DateTimeOptions = {\n    dateStyle: \"medium\",\n    timeStyle: \"short\",\n    timeZone: defaultTimezone,\n    accessibility: true,\n    locale: defaultLocale,\n    inputFormat: \"auto\",\n  };\n\n  // Parse the directive binding\n  const { mode, value, options } = parseDirectiveBinding(\n    binding,\n    defaultOptions,\n  );\n\n  // Get the date value based on mode\n  let dateValue: Date | null;\n  let rawValue: string | number;\n\n  if (mode === \"implicit\" || mode === \"options\") {\n    rawValue = extractElementValue(el, \"\");\n    dateValue = validateDateValue(rawValue, \"DateTime\");\n  } else {\n    rawValue = value as string | number;\n    dateValue = validateDateValue(rawValue, \"DateTime\");\n  }\n\n  if (dateValue === null) {\n    return;\n  }\n\n  try {\n    // Format using Intl.DateTimeFormat\n    const formatterOptions: Intl.DateTimeFormatOptions = {};\n\n    if (options.dateStyle && options.dateStyle !== \"none\") {\n      formatterOptions.dateStyle = options.dateStyle;\n    }\n\n    if (options.timeStyle && options.timeStyle !== \"none\") {\n      formatterOptions.timeStyle = options.timeStyle;\n    }\n\n    if (options.timeZone) {\n      formatterOptions.timeZone = options.timeZone;\n    }\n\n    const formatter = new Intl.DateTimeFormat(options.locale, formatterOptions);\n    const formatted = formatter.format(dateValue);\n\n    // Apply common attributes and additional datetime-specific attributes\n    applyCommonAttributes(\n      el,\n      options,\n      formatted,\n      \"Date\",\n      {\n        \"data-date-value\": dateValue.toISOString(),\n        \"data-timezone\": options.timeZone || \"UTC\",\n      },\n      rawValue,\n    );\n  } catch (error) {\n    handleDirectiveError(\"DateTime\", error, value);\n  }\n}\n\nexport default DateTimeDirective;\n","/**\n * Browser auto-detection utilities for locale, timezone, and currency\n */\n\n/**\n * Detects user's locale from browser\n * Uses multiple fallback methods for maximum compatibility\n */\nexport function detectUserLocale(): string {\n  try {\n    // Try navigator.language first (most accurate)\n    if (typeof navigator !== \"undefined\" && navigator.language) {\n      return navigator.language;\n    }\n\n    // Fallback to Intl API detected locale\n    if (typeof Intl !== \"undefined\") {\n      const detectedLocale = new Intl.DateTimeFormat().resolvedOptions().locale;\n      if (detectedLocale) {\n        return detectedLocale;\n      }\n    }\n\n    // Final fallback\n    return \"en-US\";\n  } catch (error) {\n    console.warn(\"Could not detect user locale:\", error);\n    return \"en-US\";\n  }\n}\n\n/**\n * Detects user's timezone from browser\n */\nexport function detectUserTimezone(): string {\n  try {\n    if (typeof Intl !== \"undefined\") {\n      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n      if (timezone) {\n        return timezone;\n      }\n    }\n\n    // Fallback to UTC if detection fails\n    return \"UTC\";\n  } catch (error) {\n    console.warn(\"Could not detect user timezone:\", error);\n    return \"UTC\";\n  }\n}\n\n/**\n * Infers user's preferred currency from locale\n * Uses Intl.NumberFormat to detect currency for locale\n */\nexport function detectUserCurrency(locale?: string): string {\n  try {\n    const userLocale = locale || detectUserLocale();\n\n    // Try to get currency from NumberFormat for the locale\n    if (typeof Intl !== \"undefined\") {\n      // Create a number formatter with currency style for the locale\n      // This will use the default currency for that locale\n      const formatter = new Intl.NumberFormat(userLocale, {\n        style: \"currency\",\n        currency: getCurrencyForLocale(userLocale),\n      });\n\n      const options = formatter.resolvedOptions();\n      if (options.currency) {\n        return options.currency;\n      }\n    }\n\n    return \"USD\"; // Fallback\n  } catch (error) {\n    console.warn(\"Could not detect user currency:\", error);\n    return \"USD\";\n  }\n}\n\n/**\n * Maps common locales to their typical currencies\n * This is a fallback when Intl API doesn't provide currency info\n * SR:\n * WARNING: This is not exhaustive and may not cover all cases\n * so you must add the currency manually if needed.\n */\nfunction getCurrencyForLocale(locale: string): string {\n  const currencyMap: Record<string, string> = {\n    // Major currencies\n    \"en-US\": \"USD\",\n    \"en-GB\": \"GBP\",\n    \"en-CA\": \"CAD\",\n    \"en-AU\": \"AUD\",\n    \"en-NZ\": \"NZD\",\n\n    // European Union\n    \"de-DE\": \"EUR\",\n    \"fr-FR\": \"EUR\",\n    \"es-ES\": \"EUR\",\n    \"it-IT\": \"EUR\",\n    \"nl-NL\": \"EUR\",\n    \"pt-PT\": \"EUR\",\n    \"el-GR\": \"EUR\",\n    \"fi-FI\": \"EUR\",\n    \"at-AT\": \"EUR\",\n    \"be-BE\": \"EUR\",\n    \"ie-IE\": \"EUR\",\n    \"lu-LU\": \"EUR\",\n    \"mt-MT\": \"EUR\",\n    \"sk-SK\": \"EUR\",\n    \"si-SI\": \"EUR\",\n    \"ee-EE\": \"EUR\",\n    \"lv-LV\": \"EUR\",\n    \"lt-LT\": \"EUR\",\n\n    // Asia Pacific\n    \"ja-JP\": \"JPY\",\n    \"ko-KR\": \"KRW\",\n    \"zh-CN\": \"CNY\",\n    \"zh-TW\": \"TWD\",\n    \"zh-HK\": \"HKD\",\n    \"th-TH\": \"THB\",\n    \"vi-VN\": \"VND\",\n    \"id-ID\": \"IDR\",\n    \"my-MY\": \"MYR\",\n    \"sg-SG\": \"SGD\",\n    \"ph-PH\": \"PHP\",\n    \"in-IN\": \"INR\",\n\n    // Americas\n    \"es-MX\": \"MXN\",\n    \"pt-BR\": \"BRL\",\n    \"es-AR\": \"ARS\",\n    \"es-CL\": \"CLP\",\n    \"es-CO\": \"COP\",\n    \"es-PE\": \"PEN\",\n    \"es-US\": \"USD\", // Spanish speakers in US\n    \"ca-CA\": \"CAD\",\n    \"en-JM\": \"JMD\",\n    \"en-BB\": \"BBD\",\n    \"en-TT\": \"TTD\",\n\n    // Others\n    \"ru-RU\": \"RUB\",\n    \"pl-PL\": \"PLN\",\n    \"tr-TR\": \"TRY\",\n    \"he-IL\": \"ILS\",\n    \"ar-SA\": \"SAR\",\n    \"ar-AE\": \"AED\",\n    \"no-NO\": \"NOK\",\n    \"sv-SE\": \"SEK\",\n    \"da-DK\": \"DKK\",\n    \"cs-CZ\": \"CZK\",\n    \"hu-HU\": \"HUF\",\n    \"ro-RO\": \"RON\",\n    \"bg-BG\": \"BGN\",\n    \"hr-HR\": \"HRK\",\n    \"uk-UA\": \"UAH\",\n  };\n\n  // Try exact match first\n  if (currencyMap[locale]) {\n    return currencyMap[locale];\n  }\n\n  // Try language code only (e.g., \"en\" from \"en-US\")\n  const languageCode = locale.split(\"-\")[0];\n  const matchingLocale = Object.keys(currencyMap).find(key =>\n    key.startsWith(languageCode + \"-\"),\n  );\n\n  if (matchingLocale) {\n    return currencyMap[matchingLocale];\n  }\n\n  // Default fallback\n  return \"USD\";\n}\n\n/**\n * Detects all user preferences at once\n * Returns an object with locale, timezone, and currency\n */\nexport function detectUserPreferences(): {\n  locale: string;\n  timezone: string;\n  currency: string;\n} {\n  const locale = detectUserLocale();\n  const timezone = detectUserTimezone();\n  const currency = detectUserCurrency(locale);\n\n  return {\n    locale,\n    timezone,\n    currency,\n  };\n}\n\n/**\n * Checks if the browser supports the required Intl APIs\n */\nexport function hasBrowserSupport(): {\n  intl: boolean;\n  dateTimeFormat: boolean;\n  numberFormat: boolean;\n  navigator: boolean;\n} {\n  return {\n    intl: typeof Intl !== \"undefined\",\n    dateTimeFormat:\n      typeof Intl !== \"undefined\" && typeof Intl.DateTimeFormat === \"function\",\n    numberFormat:\n      typeof Intl !== \"undefined\" && typeof Intl.NumberFormat === \"function\",\n    navigator:\n      typeof navigator !== \"undefined\" &&\n      typeof navigator.language === \"string\",\n  };\n}\n","import type { App } from \"vue\";\nimport CurrencyDirective from \"./directives/currency\";\nimport NumberDirective from \"./directives/number\";\nimport DateTimeDirective from \"./directives/datetime\";\nimport type { VueTextUtilsOptions } from \"./types\";\nimport { detectUserPreferences } from \"./utils/auto-detect\";\n\n// Export individual directives for manual registration\nexport { CurrencyDirective, NumberDirective, DateTimeDirective };\n\n// Export utilities\nexport {\n  detectUserLocale,\n  detectUserTimezone,\n  detectUserCurrency,\n  detectUserPreferences,\n  hasBrowserSupport,\n} from \"./utils/auto-detect\";\n\n// Export types\nexport type {\n  VueTextUtilsOptions,\n  CurrencyFormatOptions,\n  NumberFormatOptions,\n  DateTimeFormatOptions,\n} from \"./types\";\n\n// Export all directives for easy registration\nexport const formatDirectives = {\n  currency: CurrencyDirective,\n  number: NumberDirective,\n  \"date-time\": DateTimeDirective,\n};\n\n// Global options storage\nlet globalOptions: VueTextUtilsOptions = {\n  locale: \"en-US\",\n  defaultCurrency: \"USD\",\n  defaultTimezone: \"UTC\",\n  autoDetect: true,\n  debug: false,\n};\n\n// Function to get global options (used by directives)\nexport const getGlobalOptions = (): VueTextUtilsOptions => globalOptions;\n\n// Function to update global options at runtime\nexport const updateGlobalOptions = (\n  newOptions: Partial<VueTextUtilsOptions>,\n): void => {\n  const previousOptions = { ...globalOptions };\n  globalOptions = { ...globalOptions, ...newOptions };\n\n  if (globalOptions.debug) {\n    console.log(\"VueTextUtils options updated:\", {\n      previous: previousOptions,\n      new: globalOptions,\n      changes: newOptions,\n    });\n  }\n};\n\n// Function to reset global options to defaults\nexport const resetGlobalOptions = (): void => {\n  const autoDetectedPrefs = detectUserPreferences();\n  globalOptions = {\n    locale: autoDetectedPrefs?.locale || \"en-US\",\n    defaultCurrency: autoDetectedPrefs?.currency || \"USD\",\n    defaultTimezone: autoDetectedPrefs?.timezone || \"UTC\",\n    autoDetect: true,\n    debug: false,\n  };\n\n  if (globalOptions.debug) {\n    console.log(\"VueTextUtils options reset to auto-detected:\", globalOptions);\n  }\n};\n\n// Main plugin that registers all directives\nexport const VueTextUtils = {\n  install(app: App, options: VueTextUtilsOptions = {}) {\n    // Auto-detect user preferences if enabled\n    const autoDetectedPrefs =\n      options.autoDetect !== false ? detectUserPreferences() : null;\n\n    // Merge user options with auto-detected preferences and defaults\n    globalOptions = {\n      locale: options.locale || autoDetectedPrefs?.locale || \"en-US\",\n      defaultCurrency:\n        options.defaultCurrency || autoDetectedPrefs?.currency || \"USD\",\n      defaultTimezone:\n        options.defaultTimezone || autoDetectedPrefs?.timezone || \"UTC\",\n      autoDetect: options.autoDetect ?? true,\n      debug: options.debug ?? false,\n    };\n\n    if (globalOptions.debug) {\n      console.log(\"VueTextUtils initialized with options:\", globalOptions);\n      if (autoDetectedPrefs) {\n        console.log(\"Auto-detected user preferences:\", autoDetectedPrefs);\n      }\n    }\n\n    // Make global options and update functions available to the app\n    app.provide(\"vueTextUtilsOptions\", globalOptions);\n    app.provide(\"updateVueTextUtilsOptions\", updateGlobalOptions);\n    app.provide(\"resetVueTextUtilsOptions\", resetGlobalOptions);\n\n    // Add global properties for easy access in components\n    app.config.globalProperties.$vueTextUtils = {\n      getOptions: getGlobalOptions,\n      updateOptions: updateGlobalOptions,\n      resetOptions: resetGlobalOptions,\n    };\n\n    // Register all format directives\n    Object.entries(formatDirectives).forEach(([name, directive]) => {\n      app.directive(name, directive);\n      app.directive(`format.${name}`, directive);\n    });\n  },\n};\n"],"names":["capturedTextContent","WeakMap","mutationObservers","createDirective","formatter","pendingTasks","latestBindings","scheduleFormat","el","binding","currentText","textContent","set","get","queueMicrotask","delete","currentBinding","mounted","value","getGlobalOptions","debug","console","warn","updated","unmounted","observer","disconnect","getDefaultLocale","globalOpts","instance","_a","$i18n","locale","parseDirectiveBinding","defaultOptions","mode","options","__spreadValues","Array","isArray","Date","extractedValue","restOptions","__objRest","extractElementValue","fallback","captured","storedRawValue","getAttribute","trim","textAsNumber","replace","isLikelyRawNumber","test","storedAsNumber","storedIsRawNumber","setAttribute","trimmedContent","applyCommonAttributes","formatted","ariaPrefix","additionalAttrs","rawValue","String","accessibility","Object","entries","forEach","key","class","classList","add","handleDirectiveError","directiveName","error","Error","validateNumericValue","numericValue","parseFloat","isNaN","validateDateValue","parsed","getTime","CurrencyDirective","arg","defaultLocale","currency","defaultCurrency","currencyDisplay","minimumFractionDigits","maximumFractionDigits","Intl","NumberFormat","style","format","toString","NumberDirective","useGrouping","percentage","formatterOptions","DateTimeDirective","dateStyle","timeStyle","timeZone","defaultTimezone","inputFormat","dateValue","DateTimeFormat","toISOString","detectUserLocale","navigator","language","detectedLocale","resolvedOptions","detectUserTimezone","timezone","detectUserCurrency","userLocale","getCurrencyForLocale","currencyMap","languageCode","split","matchingLocale","keys","find","startsWith","detectUserPreferences","formatDirectives","number","globalOptions","autoDetect","updateGlobalOptions","newOptions","previousOptions","log","previous","new","changes","resetGlobalOptions","autoDetectedPrefs","VueTextUtils","install","app","_b","provide","config","globalProperties","$vueTextUtils","getOptions","updateOptions","resetOptions","name","directive","intl","dateTimeFormat","numberFormat"],"mappings":"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"}