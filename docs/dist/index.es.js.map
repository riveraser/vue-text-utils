{"version":3,"file":"index.es.js","sources":["../src/utils/directive-helpers.ts","../src/directives/currency.ts","../src/directives/number.ts","../src/directives/datetime.ts","../src/utils/auto-detect.ts","../src/index.ts"],"sourcesContent":["/***\n * SER:\n *\n * Helper functions and types for Vue.js formatting directives\n * This will do a DRY implementation of common logic used across\n * different formatting directives like number, currency, and datetime.\n */\n\nimport type { DirectiveBinding } from \"vue\";\nimport { getGlobalOptions } from \"../index\";\n\n/**\n * Common directive binding modes\n */\nexport type DirectiveMode = \"implicit\" | \"options\" | \"explicit\";\n\n/**\n * Base options that all formatting directives share\n */\nexport interface BaseFormatOptions {\n  locale?: string;\n  accessibility?: boolean;\n  class?: string;\n}\n\n/**\n * Result of parsing directive binding\n */\nexport interface DirectiveParseResult<T extends BaseFormatOptions> {\n  mode: DirectiveMode;\n  value: unknown;\n  options: T;\n}\n\n// Store for captured textContent (used for implicit mode reactivity)\nconst capturedTextContent = new WeakMap<HTMLElement, string>();\nconst mutationObservers = new WeakMap<HTMLElement, MutationObserver>();\n\n/**\n * Common directive lifecycle handlers\n */\nexport function createDirective(\n  formatter: (el: HTMLElement, binding: DirectiveBinding) => void,\n) {\n  const pendingTasks = new WeakMap<HTMLElement, boolean>();\n  const latestBindings = new WeakMap<HTMLElement, DirectiveBinding>();\n\n  const scheduleFormat = (el: HTMLElement, binding: DirectiveBinding) => {\n    // Capture the current textContent synchronously before any async operations\n    // This is crucial for implicit mode where Vue updates the textContent\n    const currentText = el.textContent || \"\";\n    capturedTextContent.set(el, currentText);\n\n    latestBindings.set(el, binding);\n\n    if (pendingTasks.get(el)) {\n      return;\n    }\n\n    pendingTasks.set(el, true);\n    queueMicrotask(() => {\n      pendingTasks.delete(el);\n      const currentBinding = latestBindings.get(el) || binding;\n      formatter(el, currentBinding);\n    });\n  };\n\n  const mountDirective = (el: HTMLElement, binding: DirectiveBinding) => {\n    // Warn about implicit mode with reactive data\n    if (binding.value === undefined || binding.value === null) {\n      const globalOpts = getGlobalOptions();\n      if (globalOpts.debug) {\n        console.warn(\n          \"[VueTextUtils] Implicit mode detected. Note: Implicit mode with {{ }} interpolation does NOT support reactivity. \" +\n            'For reactive data, use explicit mode instead: v-currency=\"yourValue\" instead of v-currency>{{ yourValue }}',\n        );\n      }\n    }\n    scheduleFormat(el, binding);\n  };\n\n  const unmountDirective = (el: HTMLElement) => {\n    // Clean up the observer when the directive is unmounted\n    const observer = mutationObservers.get(el);\n    if (observer) {\n      observer.disconnect();\n      mutationObservers.delete(el);\n    }\n  };\n\n  return {\n    mounted: mountDirective,\n    updated: scheduleFormat,\n    unmounted: unmountDirective,\n  };\n}\n\n/**\n * Get the default locale with proper priority\n */\nexport function getDefaultLocale(binding: DirectiveBinding): string {\n  const globalOpts = getGlobalOptions();\n  const instance = binding.instance as { $i18n?: { locale?: string } } | null;\n  return instance?.$i18n?.locale || globalOpts.locale || \"en-US\";\n}\n\n/**\n * Determine directive mode and extract value/options\n */\nexport function parseDirectiveBinding<T extends BaseFormatOptions>(\n  binding: DirectiveBinding,\n  defaultOptions: T,\n): DirectiveParseResult<T> {\n  const { value } = binding;\n\n  if (value === undefined || value === null) {\n    return {\n      mode: \"implicit\",\n      value: undefined,\n      options: { ...defaultOptions },\n    };\n  }\n\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    !(value instanceof Date)\n  ) {\n    // Check if the object has a 'value' property for explicit mode with options\n    const hasValueProp = \"value\" in value && value.value !== undefined;\n\n    if (hasValueProp) {\n      // Explicit mode with options: { value: 123, currency: 'EUR' }\n      // This supports reactivity because the value is passed as binding.value.value\n      const { value: extractedValue, ...restOptions } = value;\n      return {\n        mode: \"explicit\",\n        value: extractedValue,\n        options: { ...defaultOptions, ...restOptions },\n      };\n    } else {\n      // Implicit mode with options: v-currency=\"{ currency: 'EUR' }\">{{ value }}\n      // Note: This does NOT support reactivity with {{ }} interpolation\n      return {\n        mode: \"options\",\n        value: undefined,\n        options: { ...defaultOptions, ...value },\n      };\n    }\n  }\n\n  return {\n    mode: \"explicit\",\n    value: value,\n    options: { ...defaultOptions },\n  };\n}\n\n/**\n * Extract value from element or data attribute\n */\nexport function extractElementValue(\n  el: HTMLElement,\n  fallback: string = \"\",\n): string {\n  // Try to get the captured textContent from Vue's render (before any async operations)\n  const captured = capturedTextContent.get(el);\n  const textContent = captured !== undefined ? captured : el.textContent || \"\";\n  const storedRawValue = el.getAttribute(\"data-raw-value\");\n\n  // Check if we have a stored raw value from previous formatting\n  if (storedRawValue !== null) {\n    // If the text content is the same as the stored raw value, return it\n    if (textContent.trim() === storedRawValue.trim()) {\n      return storedRawValue;\n    }\n\n    // Text content has changed - determine if it's a Vue update or our own formatting\n    // Check if the text content appears to be a plain number (potential raw value from Vue)\n    const textAsNumber = textContent.replace(/^\\s+|\\s+$/g, \"\");\n    const isLikelyRawNumber = /^-?\\d+(\\.\\d+)?$/.test(textAsNumber);\n\n    // Check if the stored raw value is a plain number\n    const storedAsNumber = storedRawValue.replace(/^\\s+|\\s+$/g, \"\");\n    const storedIsRawNumber = /^-?\\d+(\\.\\d+)?$/.test(storedAsNumber);\n\n    // If both look like raw numbers and they're different, Vue has updated the value\n    if (\n      isLikelyRawNumber &&\n      storedIsRawNumber &&\n      textAsNumber !== storedAsNumber\n    ) {\n      el.setAttribute(\"data-raw-value\", textContent.trim());\n      return textContent.trim();\n    }\n\n    // If the current text looks like a raw number but stored value doesn't,\n    // Vue has updated with a new raw value\n    if (isLikelyRawNumber && !storedIsRawNumber) {\n      el.setAttribute(\"data-raw-value\", textContent.trim());\n      return textContent.trim();\n    }\n\n    // Default case: assume the directive hasn't run yet and use stored raw value\n    return storedRawValue;\n  }\n\n  // If no stored value, use text content and store it for future updates\n  const trimmedContent = textContent.trim();\n  if (trimmedContent) {\n    el.setAttribute(\"data-raw-value\", trimmedContent);\n  }\n\n  // Fall back to data-value attribute or the provided fallback\n  return trimmedContent || el.getAttribute(\"data-value\") || fallback;\n}\n\n/**\n * Apply common accessibility attributes and classes\n */\nexport function applyCommonAttributes(\n  el: HTMLElement,\n  options: BaseFormatOptions,\n  formatted: string,\n  ariaPrefix: string,\n  additionalAttrs: Record<string, string> = {},\n  rawValue?: string | number,\n): void {\n  // Update element content\n  el.textContent = formatted;\n\n  // Store the original raw value for future updates\n  if (rawValue !== undefined) {\n    el.setAttribute(\"data-raw-value\", String(rawValue));\n  }\n\n  // Add accessibility attributes if enabled\n  if (options.accessibility) {\n    el.setAttribute(\"aria-label\", `${ariaPrefix}: ${formatted}`);\n\n    // Apply additional attributes\n    Object.entries(additionalAttrs).forEach(([key, value]) => {\n      el.setAttribute(key, value);\n    });\n  }\n\n  // Add custom class if provided\n  if (options.class) {\n    el.classList.add(options.class);\n  }\n}\n\n/**\n * Handle directive errors consistently\n */\nexport function handleDirectiveError(\n  directiveName: string,\n  error: unknown,\n  value?: unknown,\n): void {\n  if (error instanceof Error) {\n    console.error(`${directiveName} directive formatting error:`, error);\n  } else {\n    console.warn(`${directiveName} directive: Invalid value:`, value);\n  }\n}\n\n/**\n * Validate numeric input\n */\nexport function validateNumericValue(\n  value: unknown,\n  directiveName: string,\n): number | null {\n  const numericValue = parseFloat(String(value));\n  if (isNaN(numericValue)) {\n    console.warn(`${directiveName} directive: Invalid numeric value:`, value);\n    return null;\n  }\n  return numericValue;\n}\n\n/**\n * Validate date input\n */\nexport function validateDateValue(\n  value: unknown,\n  directiveName: string,\n): Date | null {\n  if (value instanceof Date) {\n    return value;\n  }\n\n  if (typeof value === \"string\" || typeof value === \"number\") {\n    const parsed = new Date(value);\n    if (isNaN(parsed.getTime())) {\n      console.warn(`${directiveName} directive: Invalid date value:`, value);\n      return null;\n    }\n    return parsed;\n  }\n\n  console.warn(`${directiveName} directive: Invalid date value:`, value);\n  return null;\n}\n","import type { Directive, DirectiveBinding } from \"vue\";\nimport { getGlobalOptions } from \"../index\";\nimport {\n  createDirective,\n  parseDirectiveBinding,\n  extractElementValue,\n  applyCommonAttributes,\n  handleDirectiveError,\n  validateNumericValue,\n  getDefaultLocale,\n  type BaseFormatOptions,\n} from \"../utils/directive-helpers\";\n\n// Extend base options with currency-specific options\ninterface CurrencyOptions extends BaseFormatOptions {\n  currency?: string;\n  currencyDisplay?: \"symbol\" | \"code\" | \"name\";\n  minimumFractionDigits?: number;\n  maximumFractionDigits?: number;\n}\n\n// Currency formatting directive\nconst CurrencyDirective: Directive = createDirective(formatCurrency);\n\nfunction formatCurrency(el: HTMLElement, binding: DirectiveBinding) {\n  const { arg } = binding;\n  const globalOpts = getGlobalOptions();\n\n  // Get default options\n  const defaultLocale = getDefaultLocale(binding);\n  const defaultCurrency = arg || globalOpts.defaultCurrency || \"USD\";\n\n  const defaultOptions: CurrencyOptions = {\n    currency: defaultCurrency,\n    currencyDisplay: \"symbol\",\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n    accessibility: true,\n    locale: defaultLocale,\n  };\n\n  // Parse the directive binding\n  const { mode, value, options } = parseDirectiveBinding(\n    binding,\n    defaultOptions,\n  );\n\n  // Override currency if arg is provided (for options mode)\n  if (mode === \"options\" && arg) {\n    options.currency = arg;\n  }\n\n  // Get the numeric value based on mode\n  let numericValue: number | null;\n  let rawValue: string | number;\n\n  if (mode === \"implicit\" || mode === \"options\") {\n    rawValue = extractElementValue(el, \"0\");\n    numericValue = validateNumericValue(rawValue, \"Currency\");\n  } else {\n    rawValue = value as string | number;\n    numericValue = validateNumericValue(rawValue, \"Currency\");\n  }\n\n  if (numericValue === null) {\n    return;\n  }\n\n  try {\n    // Use Intl.NumberFormat for currency formatting\n    const formatter = new Intl.NumberFormat(options.locale, {\n      style: \"currency\",\n      currency: options.currency,\n      currencyDisplay: options.currencyDisplay,\n      minimumFractionDigits: options.minimumFractionDigits,\n      maximumFractionDigits: options.maximumFractionDigits,\n    });\n\n    const formatted = formatter.format(numericValue);\n\n    // Apply common attributes and additional currency-specific attributes\n    applyCommonAttributes(\n      el,\n      options,\n      formatted,\n      \"Currency\",\n      {\n        \"data-currency-value\": numericValue.toString(),\n        \"data-currency-code\": options.currency || \"USD\",\n      },\n      rawValue,\n    );\n  } catch (error) {\n    handleDirectiveError(\"Currency\", error, value);\n  }\n}\n\nexport default CurrencyDirective;\n","import type { Directive, DirectiveBinding } from \"vue\";\nimport {\n  createDirective,\n  parseDirectiveBinding,\n  extractElementValue,\n  applyCommonAttributes,\n  handleDirectiveError,\n  validateNumericValue,\n  getDefaultLocale,\n  type BaseFormatOptions,\n} from \"../utils/directive-helpers\";\n\n// Extend base options with number-specific options\ninterface NumberOptions extends BaseFormatOptions {\n  minimumFractionDigits?: number;\n  maximumFractionDigits?: number;\n  useGrouping?: boolean;\n  percentage?: boolean;\n}\n\n/**\n * Number formatting directive\n */\nconst NumberDirective: Directive = createDirective(formatNumber);\n\nfunction formatNumber(el: HTMLElement, binding: DirectiveBinding) {\n  // Get default options\n  const defaultLocale = getDefaultLocale(binding);\n\n  const defaultOptions: NumberOptions = {\n    minimumFractionDigits: undefined,\n    maximumFractionDigits: undefined,\n    useGrouping: true,\n    percentage: false,\n    accessibility: true,\n    locale: defaultLocale,\n  };\n\n  // Parse the directive binding\n  const { mode, value, options } = parseDirectiveBinding(\n    binding,\n    defaultOptions,\n  );\n\n  // Get the numeric value based on mode\n  let numericValue: number | null;\n  let rawValue: string | number;\n\n  if (mode === \"implicit\" || mode === \"options\") {\n    rawValue = extractElementValue(el, \"0\");\n    numericValue = validateNumericValue(rawValue, \"Number\");\n  } else {\n    rawValue = value as string | number;\n    numericValue = validateNumericValue(rawValue, \"Number\");\n  }\n\n  if (numericValue === null) {\n    return;\n  }\n\n  try {\n    // Use Intl.NumberFormat for number formatting\n    const formatterOptions: Intl.NumberFormatOptions = {\n      useGrouping: options.useGrouping,\n      minimumFractionDigits: options.minimumFractionDigits,\n      maximumFractionDigits: options.maximumFractionDigits,\n    };\n\n    const formatter = new Intl.NumberFormat(options.locale, formatterOptions);\n\n    let formatted: string;\n    if (options.percentage) {\n      // For percentage, multiply by 100 and add % symbol\n      formatted = formatter.format(numericValue * 100) + \"%\";\n    } else {\n      formatted = formatter.format(numericValue);\n    }\n\n    // Apply common attributes and additional number-specific attributes\n    applyCommonAttributes(\n      el,\n      options,\n      formatted,\n      \"Number\",\n      {\n        \"data-number-value\": numericValue.toString(),\n      },\n      rawValue,\n    );\n  } catch (error) {\n    handleDirectiveError(\"Number\", error, value);\n  }\n}\n\nexport default NumberDirective;\n","import type { Directive, DirectiveBinding } from \"vue\";\nimport { getGlobalOptions } from \"../index\";\nimport {\n  createDirective,\n  parseDirectiveBinding,\n  extractElementValue,\n  applyCommonAttributes,\n  handleDirectiveError,\n  validateDateValue,\n  getDefaultLocale,\n  type BaseFormatOptions,\n} from \"../utils/directive-helpers\";\n\n// Extend base options with datetime-specific options\ninterface DateTimeOptions extends BaseFormatOptions {\n  dateStyle?: \"full\" | \"long\" | \"medium\" | \"short\" | \"none\";\n  timeStyle?: \"full\" | \"long\" | \"medium\" | \"short\" | \"none\";\n  timeZone?: string;\n  inputFormat?: \"auto\";\n}\n\n/**\n * DateTime formatting directive\n */\nconst DateTimeDirective: Directive = createDirective(formatDateTime);\n\nfunction formatDateTime(el: HTMLElement, binding: DirectiveBinding) {\n  const globalOpts = getGlobalOptions();\n\n  // Get default options\n  const defaultLocale = getDefaultLocale(binding);\n  const defaultTimezone = globalOpts.defaultTimezone || \"UTC\";\n\n  const defaultOptions: DateTimeOptions = {\n    dateStyle: \"medium\",\n    timeStyle: \"short\",\n    timeZone: defaultTimezone,\n    accessibility: true,\n    locale: defaultLocale,\n    inputFormat: \"auto\",\n  };\n\n  // Parse the directive binding\n  const { mode, value, options } = parseDirectiveBinding(\n    binding,\n    defaultOptions,\n  );\n\n  // Get the date value based on mode\n  let dateValue: Date | null;\n  let rawValue: string | number;\n\n  if (mode === \"implicit\" || mode === \"options\") {\n    rawValue = extractElementValue(el, \"\");\n    dateValue = validateDateValue(rawValue, \"DateTime\");\n  } else {\n    rawValue = value as string | number;\n    dateValue = validateDateValue(rawValue, \"DateTime\");\n  }\n\n  if (dateValue === null) {\n    return;\n  }\n\n  try {\n    // Format using Intl.DateTimeFormat\n    const formatterOptions: Intl.DateTimeFormatOptions = {};\n\n    if (options.dateStyle && options.dateStyle !== \"none\") {\n      formatterOptions.dateStyle = options.dateStyle;\n    }\n\n    if (options.timeStyle && options.timeStyle !== \"none\") {\n      formatterOptions.timeStyle = options.timeStyle;\n    }\n\n    if (options.timeZone) {\n      formatterOptions.timeZone = options.timeZone;\n    }\n\n    const formatter = new Intl.DateTimeFormat(options.locale, formatterOptions);\n    const formatted = formatter.format(dateValue);\n\n    // Apply common attributes and additional datetime-specific attributes\n    applyCommonAttributes(\n      el,\n      options,\n      formatted,\n      \"Date\",\n      {\n        \"data-date-value\": dateValue.toISOString(),\n        \"data-timezone\": options.timeZone || \"UTC\",\n      },\n      rawValue,\n    );\n  } catch (error) {\n    handleDirectiveError(\"DateTime\", error, value);\n  }\n}\n\nexport default DateTimeDirective;\n","/**\n * Browser auto-detection utilities for locale, timezone, and currency\n */\n\n/**\n * Detects user's locale from browser\n * Uses multiple fallback methods for maximum compatibility\n */\nexport function detectUserLocale(): string {\n  try {\n    // Try navigator.language first (most accurate)\n    if (typeof navigator !== \"undefined\" && navigator.language) {\n      return navigator.language;\n    }\n\n    // Fallback to Intl API detected locale\n    if (typeof Intl !== \"undefined\") {\n      const detectedLocale = new Intl.DateTimeFormat().resolvedOptions().locale;\n      if (detectedLocale) {\n        return detectedLocale;\n      }\n    }\n\n    // Final fallback\n    return \"en-US\";\n  } catch (error) {\n    console.warn(\"Could not detect user locale:\", error);\n    return \"en-US\";\n  }\n}\n\n/**\n * Detects user's timezone from browser\n */\nexport function detectUserTimezone(): string {\n  try {\n    if (typeof Intl !== \"undefined\") {\n      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n      if (timezone) {\n        return timezone;\n      }\n    }\n\n    // Fallback to UTC if detection fails\n    return \"UTC\";\n  } catch (error) {\n    console.warn(\"Could not detect user timezone:\", error);\n    return \"UTC\";\n  }\n}\n\n/**\n * Infers user's preferred currency from locale\n * Uses Intl.NumberFormat to detect currency for locale\n */\nexport function detectUserCurrency(locale?: string): string {\n  try {\n    const userLocale = locale || detectUserLocale();\n\n    // Try to get currency from NumberFormat for the locale\n    if (typeof Intl !== \"undefined\") {\n      // Create a number formatter with currency style for the locale\n      // This will use the default currency for that locale\n      const formatter = new Intl.NumberFormat(userLocale, {\n        style: \"currency\",\n        currency: getCurrencyForLocale(userLocale),\n      });\n\n      const options = formatter.resolvedOptions();\n      if (options.currency) {\n        return options.currency;\n      }\n    }\n\n    return \"USD\"; // Fallback\n  } catch (error) {\n    console.warn(\"Could not detect user currency:\", error);\n    return \"USD\";\n  }\n}\n\n/**\n * Maps common locales to their typical currencies\n * This is a fallback when Intl API doesn't provide currency info\n * SR:\n * WARNING: This is not exhaustive and may not cover all cases\n * so you must add the currency manually if needed.\n */\nfunction getCurrencyForLocale(locale: string): string {\n  const currencyMap: Record<string, string> = {\n    // Major currencies\n    \"en-US\": \"USD\",\n    \"en-GB\": \"GBP\",\n    \"en-CA\": \"CAD\",\n    \"en-AU\": \"AUD\",\n    \"en-NZ\": \"NZD\",\n\n    // European Union\n    \"de-DE\": \"EUR\",\n    \"fr-FR\": \"EUR\",\n    \"es-ES\": \"EUR\",\n    \"it-IT\": \"EUR\",\n    \"nl-NL\": \"EUR\",\n    \"pt-PT\": \"EUR\",\n    \"el-GR\": \"EUR\",\n    \"fi-FI\": \"EUR\",\n    \"at-AT\": \"EUR\",\n    \"be-BE\": \"EUR\",\n    \"ie-IE\": \"EUR\",\n    \"lu-LU\": \"EUR\",\n    \"mt-MT\": \"EUR\",\n    \"sk-SK\": \"EUR\",\n    \"si-SI\": \"EUR\",\n    \"ee-EE\": \"EUR\",\n    \"lv-LV\": \"EUR\",\n    \"lt-LT\": \"EUR\",\n\n    // Asia Pacific\n    \"ja-JP\": \"JPY\",\n    \"ko-KR\": \"KRW\",\n    \"zh-CN\": \"CNY\",\n    \"zh-TW\": \"TWD\",\n    \"zh-HK\": \"HKD\",\n    \"th-TH\": \"THB\",\n    \"vi-VN\": \"VND\",\n    \"id-ID\": \"IDR\",\n    \"my-MY\": \"MYR\",\n    \"sg-SG\": \"SGD\",\n    \"ph-PH\": \"PHP\",\n    \"in-IN\": \"INR\",\n\n    // Americas\n    \"es-MX\": \"MXN\",\n    \"pt-BR\": \"BRL\",\n    \"es-AR\": \"ARS\",\n    \"es-CL\": \"CLP\",\n    \"es-CO\": \"COP\",\n    \"es-PE\": \"PEN\",\n    \"es-US\": \"USD\", // Spanish speakers in US\n    \"ca-CA\": \"CAD\",\n    \"en-JM\": \"JMD\",\n    \"en-BB\": \"BBD\",\n    \"en-TT\": \"TTD\",\n\n    // Others\n    \"ru-RU\": \"RUB\",\n    \"pl-PL\": \"PLN\",\n    \"tr-TR\": \"TRY\",\n    \"he-IL\": \"ILS\",\n    \"ar-SA\": \"SAR\",\n    \"ar-AE\": \"AED\",\n    \"no-NO\": \"NOK\",\n    \"sv-SE\": \"SEK\",\n    \"da-DK\": \"DKK\",\n    \"cs-CZ\": \"CZK\",\n    \"hu-HU\": \"HUF\",\n    \"ro-RO\": \"RON\",\n    \"bg-BG\": \"BGN\",\n    \"hr-HR\": \"HRK\",\n    \"uk-UA\": \"UAH\",\n  };\n\n  // Try exact match first\n  if (currencyMap[locale]) {\n    return currencyMap[locale];\n  }\n\n  // Try language code only (e.g., \"en\" from \"en-US\")\n  const languageCode = locale.split(\"-\")[0];\n  const matchingLocale = Object.keys(currencyMap).find(key =>\n    key.startsWith(languageCode + \"-\"),\n  );\n\n  if (matchingLocale) {\n    return currencyMap[matchingLocale];\n  }\n\n  // Default fallback\n  return \"USD\";\n}\n\n/**\n * Detects all user preferences at once\n * Returns an object with locale, timezone, and currency\n */\nexport function detectUserPreferences(): {\n  locale: string;\n  timezone: string;\n  currency: string;\n} {\n  const locale = detectUserLocale();\n  const timezone = detectUserTimezone();\n  const currency = detectUserCurrency(locale);\n\n  return {\n    locale,\n    timezone,\n    currency,\n  };\n}\n\n/**\n * Checks if the browser supports the required Intl APIs\n */\nexport function hasBrowserSupport(): {\n  intl: boolean;\n  dateTimeFormat: boolean;\n  numberFormat: boolean;\n  navigator: boolean;\n} {\n  return {\n    intl: typeof Intl !== \"undefined\",\n    dateTimeFormat:\n      typeof Intl !== \"undefined\" && typeof Intl.DateTimeFormat === \"function\",\n    numberFormat:\n      typeof Intl !== \"undefined\" && typeof Intl.NumberFormat === \"function\",\n    navigator:\n      typeof navigator !== \"undefined\" &&\n      typeof navigator.language === \"string\",\n  };\n}\n","import type { App } from \"vue\";\nimport CurrencyDirective from \"./directives/currency\";\nimport NumberDirective from \"./directives/number\";\nimport DateTimeDirective from \"./directives/datetime\";\nimport type { VueTextUtilsOptions } from \"./types\";\nimport { detectUserPreferences } from \"./utils/auto-detect\";\n\n// Export individual directives for manual registration\nexport { CurrencyDirective, NumberDirective, DateTimeDirective };\n\n// Export utilities\nexport {\n  detectUserLocale,\n  detectUserTimezone,\n  detectUserCurrency,\n  detectUserPreferences,\n  hasBrowserSupport,\n} from \"./utils/auto-detect\";\n\n// Export types\nexport type {\n  VueTextUtilsOptions,\n  CurrencyFormatOptions,\n  NumberFormatOptions,\n  DateTimeFormatOptions,\n} from \"./types\";\n\n// Export all directives for easy registration\nexport const formatDirectives = {\n  currency: CurrencyDirective,\n  number: NumberDirective,\n  \"date-time\": DateTimeDirective,\n};\n\n// Global options storage\nlet globalOptions: VueTextUtilsOptions = {\n  locale: \"en-US\",\n  defaultCurrency: \"USD\",\n  defaultTimezone: \"UTC\",\n  autoDetect: true,\n  debug: false,\n};\n\n// Function to get global options (used by directives)\nexport const getGlobalOptions = (): VueTextUtilsOptions => globalOptions;\n\n// Function to update global options at runtime\nexport const updateGlobalOptions = (\n  newOptions: Partial<VueTextUtilsOptions>,\n): void => {\n  const previousOptions = { ...globalOptions };\n  globalOptions = { ...globalOptions, ...newOptions };\n\n  if (globalOptions.debug) {\n    console.log(\"VueTextUtils options updated:\", {\n      previous: previousOptions,\n      new: globalOptions,\n      changes: newOptions,\n    });\n  }\n};\n\n// Function to reset global options to defaults\nexport const resetGlobalOptions = (): void => {\n  const autoDetectedPrefs = detectUserPreferences();\n  globalOptions = {\n    locale: autoDetectedPrefs?.locale || \"en-US\",\n    defaultCurrency: autoDetectedPrefs?.currency || \"USD\",\n    defaultTimezone: autoDetectedPrefs?.timezone || \"UTC\",\n    autoDetect: true,\n    debug: false,\n  };\n\n  if (globalOptions.debug) {\n    console.log(\"VueTextUtils options reset to auto-detected:\", globalOptions);\n  }\n};\n\n// Main plugin that registers all directives\nexport const VueTextUtils = {\n  install(app: App, options: VueTextUtilsOptions = {}) {\n    // Auto-detect user preferences if enabled\n    const autoDetectedPrefs =\n      options.autoDetect !== false ? detectUserPreferences() : null;\n\n    // Merge user options with auto-detected preferences and defaults\n    globalOptions = {\n      locale: options.locale || autoDetectedPrefs?.locale || \"en-US\",\n      defaultCurrency:\n        options.defaultCurrency || autoDetectedPrefs?.currency || \"USD\",\n      defaultTimezone:\n        options.defaultTimezone || autoDetectedPrefs?.timezone || \"UTC\",\n      autoDetect: options.autoDetect ?? true,\n      debug: options.debug ?? false,\n    };\n\n    if (globalOptions.debug) {\n      console.log(\"VueTextUtils initialized with options:\", globalOptions);\n      if (autoDetectedPrefs) {\n        console.log(\"Auto-detected user preferences:\", autoDetectedPrefs);\n      }\n    }\n\n    // Make global options and update functions available to the app\n    app.provide(\"vueTextUtilsOptions\", globalOptions);\n    app.provide(\"updateVueTextUtilsOptions\", updateGlobalOptions);\n    app.provide(\"resetVueTextUtilsOptions\", resetGlobalOptions);\n\n    // Add global properties for easy access in components\n    app.config.globalProperties.$vueTextUtils = {\n      getOptions: getGlobalOptions,\n      updateOptions: updateGlobalOptions,\n      resetOptions: resetGlobalOptions,\n    };\n\n    // Register all format directives\n    Object.entries(formatDirectives).forEach(([name, directive]) => {\n      app.directive(name, directive);\n      app.directive(`format.${name}`, directive);\n    });\n  },\n};\n"],"names":[],"mappings":"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"}